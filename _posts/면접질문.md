
## 

## DB 클러스터링과 리플리케이션의 차이점
클러스터링은  DB서버를 다중화 하는 것이고 리플리케이션은 서버와 데이터를 같이 다중화 하는 것

## Call by value, Call by reference
a = 10; b = a; 라고 하면 b는 10이 들어가는게 아니고 a의 주소가 복사가 된다. 그래서 b를 수정하면 a에도 영향을 미치는게 call by reference
call by value 는 a = 10; b = a; 했을 때 b = 10이 된다. b를 수정해도 a에 영향을 주지 않는다.

## JVM 구조
- Method(Static) Area
class의 구조 정보가 들어간다.

- Stack Area
Method정보, 메소드 호출 시 사용하는 지역변수 데이터 등을 저장한다. {}가 끝나는 동안 유지된다.
JVM시작시 생성되고 프로그램이 종료될때까지 유지된다.

- Heap Area
new 를 한게 여기로 들어감 gc의 주요 대상이다

## restFul API와 SOAP에 대해 각각 설명하고 차이점을 말하세요.

-SOAP(Simple Object Access Protocol)
HTTP프로토콜 위에서 XML로 통신한다.

-Restful API(Representational State Transfer)
HTTP를 통해 CRUD를 실행하는 API

## 웹 공격 패턴과 방어 방법에 대해 설명 해보세요.

1.sql 인젝션 공격
- 웹의 취약점을 이용해 개발자가 예상하지 못한 sql이 실행 되도록 하는 공격. 예를 들면 물건에 입금이 안되었는데 입금 처리 필드를 0에서 1로 바꾸는 등.
막는 방법은 값을 검사해서 해당 값만 들어갈 수 있게 한다. 예를들어 숫자만 가능하게 한다던지 이메일 필드는 해당 패턴만 가능하게 한다던지 등.

2.CSRF크로스 사이트 스크립트 공격
3.리퀘스트 변조
- admin page기능을 회사 사람이 아닌 해커가 호출을 하는 경우이다. 보안 token을 발행하여 해당 토큰이 없으면 액세스 하지 못하게 막는다.

## C#
### string과 StringBuffer의 차이점에 대해서 설명해주세요. 
- string 클래스는 변경이 불가능한 immutable 클래스이고,
- stringBuffer 클래스는 변경이 가능한 mutable 클래스이다.

### using 이라는 키워드는 네임스페이스를 링크하기 위해서 사용하기도 하지만 객체를 생성할 때 또한 사용되기도 합니다. 이때 using을 이용하는 목적에 대해서 설명해주세요.

- 일반적으로 객체를 생성할 경우 메모리에 데이터가 올라가고 메모리 자원관리를 위해 객체 사용이 끝난 다음에 DIspose()를 해주어야 합니다. using문을 사용해서 객체를 사용하면 using문의 {}를 벗어나면 객체에 관련된 자원(혹은 객체에서 사용한 자원)이 자동으로 해제되며 예외 발생시에도 자원을 해제해줍니다.
- 참고 : IDispoable 인터페이스를 구현한 객체만 using문을 사용할 수 있습니다.

###  객체를 만들 때 메모리 해제를 위해서 일반적으로 IDisposable 인터페이스를 상속받아서 처리하게 되는 경우가 많습니다. 닷넷에서의 소멸자는 Dispose(), Finalize()가 존재하는데 이 두 가지의 차이점은 무엇인지 기술해주세요.

- Dispose는 더이상 객체 사용이 불필요한 경우 명시적 제어
. 명시적으로 해제되어야 하는 리소스를 캡슐화하는 형식에 대해 dispose 디자인 패턴을 구현합니다. 사용자는 공용 Dispose 메서드를 호출하여 외부 리소스를 해제할 수 있습니다.
. 일반적으로 기본 형식에 리소스를 계속 사용하는 파생 형식이 있으면 기본 형식에서는 리소스를 계속 사용하지 않더라도 해당 기본 형식에 대해 dispose 디자인 패턴을 구현합니다. 기본 형식에 Close 메서드가 있으면 이는 대개 Dispose를 구현해야 함을 나타냅니다. 이런 경우에는 기본 형식에 대해 Finalize 메서드를 구현하지 않습니다. Finalize는 정리가 필요한 리소스를 사용하는 파생 형식에서 구현되어야 합니다.
. 형식이 소유하는 삭제 가능한 모든 리소스는 해당 Dispose 메서드에서 해제합니다.
. 인스턴스에 대해 Dispose를 호출한 후에는 GC.SuppressFinalize 메서드를 호출하여 Finalize 메서드가 실행되지 않도록 합니다. 드물지만Dispose에서 다루지 않는 작업을 Finalize에서 수행해야 하는 경우에는 이 규칙이 적용되지 않습니다.
. 기본 클래스에서 IDisposable을 구현하면 기본 클래스의 Dispose 메서드를 호출합니다.
. Dispose가 호출될 것으로 가정하지 않습니다. 형식에서 소유하는 관리되지 않는 리소스는 Dispose가 호출되지 않는 경우 Finalize 메서드에서도 해제되어야 합니다.ㄱ
. 리소스가 이미 삭제되었을 때 해당 형식(Dispose 제외)에 대한 인스턴스 메서드에서 ObjectDisposedException을 throw합니다. Dispose 메서드는 예외를 throw하지 않고 여러 번 호출할 수 있으므로 이 규칙이 적용되지 않습니다.
. 기본 형식의 계층 구조를 통해 Dispose에 대한 호출을 전파합니다. Dispose 메서드는 해당 개체와 해당 개체 소유의 모든 개체에서 사용하는 리소스를 모두 해제해야 합니다. 예를 들어, 사용자가 모르는 사이에 TextReader에 의해 만들어지는 Stream과 Encoding을 계속 사용하는 TextReader 등의 개체를 만들 수 있습니다. 또한 Stream과 Encoding은 모두 외부 리소스를 받아 들일 수 있습니다. TextReader에 대해Dispose 메서드를 호출하면 해당 개체는 Stream과 Encoding에 대해 Dispose를 호출하여 해당 외부 리소스를 해제하도록 합니다.
. Dispose 메서드가 호출된 다음에는 개체를 다시 사용할 수 없도록 하는 것이 좋습니다. 이미 삭제된 개체를 다시 만드는 것은 구현하기 어려운 패턴입니다.
. Dispose 메서드는 예외를 throw하지 않고 한 번 이상 호출될 수 있도록 합니다. 이 메서드는 처음 호출된 이후에는 아무 작업도 수행하지 않습니다.


- Finalize는 프로그래머가 Dispose 호출에 실패하는 경우 리소스가 누수되지 않도록 백업 기능 제공
. 기본 클래스의 Finalize 메서드는 C# 및 C++ 소멸자 구문을 사용하여 자동으로 호출됩니다.
. 종료가 필요한 개체에 대해서만 Finalize를 구현. Finalize 메서드를 구현하면 성능이 저하될 수 있습니다.
. Finalize 메서드가 필요하면 클래스 사용자가 Finalize 메서드를 호출할 필요가 없도록 IDisposable을 구현할 것인지 고려
. Finalize 메서드를 보다가 가시적인 메서드로 만들지 않습니다. 이 메서드는 protected여야 합니다.
. 개체의 Finalize메서드는 해당 개체가 소유하는 모든 외부 리소스를 해제해야 합니다. 또한 Finalize메서드는         
. 해당 개체에서 보유한 리소스만 해제해야 합니다. Finalize 메서드는 다른개체를 참조하지 않습니다.
. 해당 개체의 기본 클래스가 아닌 개체에 대해 Finalize 메서드를 직접 호출하지 않습니다.
. 개체의 Finalize 메서드에서 기본 클래스의 Finalize 메서드를 호출합니다.

### C# 데이터 타입은 값 타입, 참조 타입이 있음.
- 값 형식 : 값을 변수에 넣는 데이터 형식. 스택에 저장. 
  스택메모리를 미용하면 변수가 할당 된 위치의 값만 변경됨. LIFO방식. 해제시점은 변수선언 영역을 벗어날 때.
- 참조 형식 : 변수에 대한 위치(메모리 위치)를 담는 데이터 형식. 값이 복사가 아니라 주소가 복사됨. 
  스택에는 메모리 주소가, 힙에는 실질적인 값이 저장. 새로운 객체변수에 기존 변수 할당하면 스택의 메모리 주소만 복사. 값을 변경하면 참조하고 있는 모든 변수의 값이 동일해짐. 힙메모리 영역 해제시점은 알 수 없음.

### 접근 권한자
- public : 모든 외부 객체로부터 접근을 허용한다
- protected : 상속되는 파생클래스(derived class)에서만 접근할 수 있다
- private : 해당 클래스 내에서만 사용된다. 외부 혹은 파생클래스에서 접근 불가
- internal : 어셈블리(.NET Assembly)내에 있는 다른 클래스들에서 접근할 수 있다
- protected internal : 액세스가 현재 어셈블리 또는 포함하는 클래스에서 파생된 형식으로 제한됩니다.
- private protected : 액세스가 포함하는 클래스 또는 현재 어셈블리 내의 포함하는 클래스에서 파생된 형식으로 제한됩니다. C# 7.2부터 사용할 수 있습니다.

### ASP vs ASP.NET 차이점
- ASP는 인터프리터 방식. VB언어 기반 스크립트 방식. IIS상에서 운영.
- ASP.NET은 컴파일러 방식. 닷넷 언어 기반 개발. IIS, .NET Framework 에서 운영.


### Boxing & UnBoxing
