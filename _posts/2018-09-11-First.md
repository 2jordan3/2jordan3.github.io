
## Javascript

### Closure
클로져는 함수 안의 또 다른 함수를 이용해 하나의 독립된 스코프를 생성하는 메카니즘이다.

``` javascript
function counter() {
  var count = 0;
  
  function add() {
    count++;
    console.log(count);
  }
  
  return add;
}

const increaseNumber = counter();
increaseNumber();
```
counter 함수를 실행 함으로써 add 함수가 반환되는데 중요한 점은 counter 함수가 실행 된 후에도 반환된 내부 함수를 통해 count 변수에 접근이 가능 하다는 것이다. 즉, count 변수와 반환된 함수를 포함하는독립된 환경이 생성된 것이다.

자바스크립트 코어에는 private 함수나 변수의 개념이 없다. 클로져를 이용해 이런 private 함수나 변수를 만들 수 있게 된다.


### 호이스팅
. 스코프 안의 어디에서든 변수 선언은 최상위에서 선언된 것과 동등하다.

``` javascript
var x = 'outer scope';
(function() {
  console.log(x); // undefined
  var x = 'inner scope';
}());
```

. 변수가 선언되기 전에 변수를 사용할 수도 있다.

``` javascript
foo = 'bar';
var foo;
// 위는 아래와 같은 의미를 가진다.
var foo;
```
foo = 'bar';

### var vs let/const
var 변수의 경우 유효범위는 함수 스코프가 유효범위이지만, let과 const의 경우에는 블록 스코프가 유효 범위이다.

var와 let/const선언에 대한 범위의 차이 중 하나는 let/const가 TDZ에 의해 제약을 받는다는 것이다.
즉, 변수가 초기화되기 전에 액세스하려고 하면, var처럼 undefined를 반환하지 않고, ReferenceError가 발생한다. 이는 코드를 예측가능하고 잠재적 버그를 쉽게 찾아낼 수 있도록 한다.
``` javascript
console.log(x); // throws a ReferenceError
const x = 'hey';
```
위 예제를 보면, let/const선언은 호이스팅을 수행하지 않는다고 생각할 수 있다.
하지만 이는 잘못된 것이며, Hoisting에 관한 예제 코드에서 var를 const으로 바꾸면, 어떤 일이 발생하는지 살펴본다.
``` javascript
const x = 'outer scope';

(function() {
  console.log(x);
  const x = 'inner scope';
}());
```
console.log(x);는 TDZ에 의해 ReferenceError를 발생하게 된다.
이는, let/const 선언은 호이스팅을 수행하기 때문이다.
undefined를 반환하는 var와는 달리, 초기화되기 전에 액세스할 때 에러가 발생한다.

var로 선언된 변수는
[선언 - 초기화 - 할당] 의 단계 중
[선언 - 초기화]가 한번에 이루어지고 다음에 [할당]이 되게 된다.

1. [선언 - 초기화]
2. [할당]

let/const 키워드는 다르게 실행된다.
선언, 초기화, 할당이 따로 이루어지고 TDZ(Temporal Dead Zone)라는 것이 개입한다.

1. [선언] 
2. [TDZ]
3. [초기화]
4. [할당]
