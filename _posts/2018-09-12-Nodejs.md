---

layout: post

title: Node JS

---

## Callback 지옥

### 콜백지옥에 빠지기 쉬운 상황
task1 실행 이후에 task2,3,4 등이 순차적 실행
task1 실행 결과를 이용해 task2 가 실행
```javascript
task1(a, b, function (err, result1) {
    task2(c, function (err, result2) {
        task3...task4... 
    }); 
});
```

  1. Async
외부모듈이기 때문에 npm install async로 설치
series, waterfall, parallel 방법

- series(tasks[, callback]) : 각 태스크는 함수이고, 중간에 에러가 나면 다음태스크를 실행하지 않고, 완료 콜백으로 에러를 전달한다. 
  results에는 각 태스크의 결과가 배열로 전달된다.
  
```javascript
function taskA(callback) {
    setTimeout(() => {
        callback(null, 'Result');
    }, 1000);
}

function taskB(callback) {
    setTimeout(() => {
        callback(null, 'Result');
    }, 2000);
}

function taskC(callback) {
    setTimeout(() => {
        callback(null, 'Result');
    }, 3000);
}
// 위, 아래 방법이 같은 결과를 보여줍니다. (물론 출력 횟수가 다르긴 합니다.)
const async = require('async');
async.series([
    (callback) => { console.log('TaskA'); callback(null, 'ResultA'); },
    (callback) => { console.log('TaskB'); callback(null, 'ResultB'); },
    (callback) => { console.log('TaskC'); callback(null, 'ResultC'); }
])

async.series([taskA, taskB, taskC],
    (err, results) => {
        console.log('Task A, B, C', reuslts);
    }
);
```

  2. Promise
Promise의 상태는 Pending (동작 완료 전), fulfilled (동작 성공), rejected (동작 실패) 로 나누어집니다.
```javascript
function task(arg) {
    return new Promise( (resolve, reject) => {
        // 비동기 동작
        if ( success )
             resolve('Success');
        else
             reject('Error');
       });
}

task1().then( task1Result => { 
    return task2(task1Result);
 }).then(task2Result => {
     return task3(task2Result);
}).then(task3Result => {
    console.log('All Tasks Done with', task3Result);
}).catch(error => { 
    console.log(error);
});
```
------
```javascript
new Promise(function (fullfill, reject) {
    //비동기 동작 
    if (err)
        reject(err);
    else
        fullfill(result);
});

new Promise(task).then(fullfilled, rejected);
function fullfilled(result) { }
function rejected(err) { }

function task(fullfill, reject) {
    console.log('task start');
    setTimeout(function () {
        console.log('task end');
        fullfill('task success');
    }, 300);
}

function fullfilled(result) {
    console.log('fullfilled : ', result);
}

function rejected(err) {
    console.log('rejected : ', err);
}
new Promise(task).then(fullfilled, rejected);

```
  
  3. Await-Async
  
```javascript
function asyncTask() {
     return new Promise( (resolve, reject) => {
// 비동기 동작 코드 });
}

//  Promise로 실행
asyncTask().then( onfulfilled, onRejected );
//  async/await로 실행
async function doIt() {
    let result = await asyncTask();
} 
doIt();
```

## REPL
REPL 은 Read Eval Print Loop의 약자입니다. 
이는 윈도우 커맨드, 혹은 UNIX/LINUX Shell 처럼 사용자가 커맨드를 입력하면 시스템이 값을 반환하는 환경을 가르킵니다.
- Read – 유저의 값을 입력 받아 JavaScript 데이터 구조로 메모리에 저장합니다.
- Eval – 데이터를 처리(Evaluate) 합니다.
- Print – 결과값을 출력합니다.
- Loop – Read, Eval, Print 를 유저가 Ctrl+C를 두번 눌러 종료할때까지 반복합니다.
